%{
  #include <stdio.h>
  #include <math.h>
  #include <utility>

namespace eta {
  class etaFlexLexer;
}

BaseNodeArgs get_bna();

int yylex(/*yy::parser::semantic_type*/void* parser_look_ahead_sym, eta::etaFlexLexer& lexer);

%}

%code requires {
  #include "base/defs.hpp"
  #include "lexer/lexer_defs.hpp"
  #include "base/ast.hpp"

  #include <functional>

  using ProgramAstNode = eta::ast::ProgramAstNode;
  using UseAstNode = eta::ast::UseAstNode;

  namespace eta {
  struct ParserDriver;
  }

}

%parse-param { eta::etaFlexLexer& lexer  };
%parse-param { eta::ParserDriver& driver };
%lex-param   { eta::etaFlexLexer& lexer  };

%define api.value.type variant
%define api.token.prefix {TOK_}

%token <eta::TokenMeta> IDENTIFIER
%token USE_KWD WHILE_KWD IF_KWD ELSE_KWD RETURN_KWD
%token LENGTH_KWD
%token LPAREN RPAREN LBRACKET RBRACKET LBRACE RBRACE
%token COLON SEMICOLON COMMA
%token INT_TYPE BOOL_TYPE
%token TRUE_LITERAL FALSE_LITERAL
%token <eta::TokenMeta> STR_LITERAL CHAR_LITERAL INT_LITERAL
%token OP_ASSIGN OP_MINUS OP_LNOT OP_MUL OP_HIGHMUL
       OP_DIV OP_MOD OP_ADD OP_L_THAN OP_LEQ_THAN
       OP_GEQ_THAN OP_G_THAN OP_EQ OP_NEQ OP_LAND OP_LOR

%token ERROR

%nterm <use_decl>
%nterm <program>

%%

program: {= driver.create<eta::ast::ProgramAstNode>(get_bna()); }
{
  driver.m_program.m_use_list = std::move($$1);
}

use_list: {

}

use_decl: USE_KWD IDENTIFIER {
  $$ = ast::UseAstNode(get_bna(), $2.identifier_name);
}


%%

namespace eta {
extern TokenMeta symbol_to_parser;
}

int yylex(void* parser_look_ahead_sym, eta::etaFlexLexer& lexer)
{
  const int rval = lexer.yylex();
  reinterpret_cast<yy::parser::semantic_type*>(parser_look_ahead_sym)->emplace<eta::TokenMeta, eta::TokenMeta&&>(std::move(eta::symbol_to_parser));
  return rval;
}

BaseNodeArgs get_bna()
{
  return BaseNodeArgs{}; // TODO
}